generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  picture   String?
  password  String?  @map("password")
  googleId  String?  @unique @map("google_id")
  companyId String   @map("company_id")
  role      String   @default("admin") // 'admin' | 'manager' | 'agent'
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company               Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  assignedConversations Conversation[] @relation("AssignedAgent")

  @@map("users")
}

model Company {
  id        String   @id @default(cuid())
  name      String
  balance   Decimal  @default(0) @db.Decimal(10, 2)
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Stripe Subscription fields
  stripeCustomerId        String?   @unique @map("stripe_customer_id")
  subscriptionId          String?   @unique @map("subscription_id")
  subscriptionStatus      String?   @map("subscription_status") // 'active' | 'past_due' | 'canceled' | 'trialing'
  planId                  String?   @map("plan_id") // 'starter' | 'professional' | 'business' | 'enterprise'
  billingPeriod           String?   @map("billing_period") // 'monthly' | 'yearly'
  subscriptionPeriodStart DateTime? @map("subscription_period_start")
  subscriptionPeriodEnd   DateTime? @map("subscription_period_end")
  cancelAtPeriodEnd       Boolean   @default(false) @map("cancel_at_period_end")

  // Usage limits based on plan
  maxInstances        Int  @default(1) @map("max_instances")
  maxMessagesPerMonth Int  @default(1000) @map("max_messages_per_month")
  maxContacts         Int  @default(500) @map("max_contacts")
  maxCampaigns        Int? @map("max_campaigns") // null = unlimited
  maxTeamMembers      Int  @default(1) @map("max_team_members")
  aiCreditsLimit      Int  @default(100) @map("ai_credits_limit")
  aiCreditsUsed       Int  @default(0) @map("ai_credits_used")

  users     User[]
  instances Instance[]

  messages         Message[]
  chatFlows        ChatFlow[]
  products         Product[]
  contacts         Contact[]
  aiSecretary      AISecretary?
  conversations    Conversation[]
  campaigns        Campaign[]
  secretaryTasks   SecretaryTask[]
  integrations     ExternalIntegration[]
  groupAutomations GroupAutomation[]

  @@map("companies")
}

model Contact {
  id            String   @id @default(cuid())
  remoteJid     String   @map("remote_jid")
  pushName      String?  @map("push_name")
  profilePicUrl String?  @map("profile_pic_url")
  notes         String?  @db.Text
  tags          String[] @default([])

  // Campos para identificação de grupos
  isGroup          Boolean @default(false) @map("is_group") // true se for um grupo
  groupName        String? @map("group_name") // Nome do grupo (subject)
  groupDescription String? @map("group_description") @db.Text // Descrição do grupo

  // Campos demográficos para segmentação (apenas para contatos individuais)
  cep          String? // CEP para auto-preencher cidade/estado via ViaCEP
  birthDate    DateTime? @map("birth_date")
  gender       String? // 'male' | 'female' | 'other'
  city         String?
  state        String?
  neighborhood String? // Bairro (preenchido via ViaCEP)
  university   String?
  course       String?
  occupation   String?

  // Lead scoring e análise de IA
  leadScore     Int?      @map("lead_score") // 0-100
  leadStatus    String?   @map("lead_status") // 'cold' | 'warm' | 'hot' | 'customer'
  aiAnalysis    String?   @map("ai_analysis") @db.Text // Análise detalhada da IA
  aiAnalyzedAt  DateTime? @map("ai_analyzed_at")
  totalMessages Int       @default(0) @map("total_messages")

  companyId  String   @map("company_id")
  instanceId String?  @map("instance_id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  company  Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  memories ContactMemory[]

  @@unique([remoteJid, companyId])
  @@map("contacts")
}

// Memória estruturada por contato - evita reprocessar todo histórico
model ContactMemory {
  id        String @id @default(cuid())
  contactId String @map("contact_id")

  // Tipo de memória
  type       String // 'fact' | 'preference' | 'need' | 'objection' | 'interest' | 'context'
  key        String // Ex: "nome_filho", "produto_interesse", "reclamacao"
  value      String  @db.Text // O valor da informação
  confidence Float   @default(1.0) // 0-1, confiança na informação
  source     String? // messageId de onde veio a info

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([contactId, type, key])
  @@index([contactId])
  @@map("contact_memories")
}

// Base de conhecimento da empresa - treinamento específico
model CompanyKnowledge {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  category String // 'product' | 'faq' | 'policy' | 'objection_handler' | 'script' | 'error_correction'
  title    String
  content  String   @db.Text
  keywords String[] @default([]) // Para busca rápida
  priority Int      @default(0) // Maior = mais importante
  isActive Boolean  @default(true) @map("is_active")

  // Para correção de erros
  wrongResponse   String? @map("wrong_response") @db.Text
  correctResponse String? @map("correct_response") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([companyId, category])
  @@map("company_knowledge")
}

model Product {
  id        String   @id @default(cuid())
  name      String
  variant   String?
  quantity  Int      @default(0)
  price     Decimal  @db.Decimal(10, 2)
  sku       String?
  imageUrl  String?  @map("image_url")
  isActive  Boolean  @default(true) @map("is_active")
  companyId String   @map("company_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("products")
}

model ChatFlow {
  id        String   @id @default(cuid())
  name      String
  keyword   String
  isActive  Boolean  @default(true) @map("is_active")
  companyId String   @map("company_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  nodes   ChatNode[]

  @@map("chat_flows")
}

model ChatNode {
  id        String  @id @default(cuid())
  flowId    String  @map("flow_id")
  content   String  @db.Text
  type      String  @default("text") // text, button, list
  stepIndex Int     @map("step_index")
  parentId  String? @map("parent_id")

  flow ChatFlow @relation(fields: [flowId], references: [id], onDelete: Cascade)

  @@map("chat_nodes")
}

model Instance {
  id          String    @id @default(cuid())
  name        String
  instanceKey String    @unique @map("instance_key")
  companyId   String    @map("company_id")
  status      String    @default("disconnected")
  errorReason String?   @map("error_reason") // Motivo do erro de conexão
  lastErrorAt DateTime? @map("last_error_at") // Quando ocorreu o último erro
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  company       Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  messages      Message[]
  conversations Conversation[]

  @@map("instances")
}

model Message {
  id          String    @id @default(cuid())
  remoteJid   String    @map("remote_jid")
  messageId   String    @unique @map("message_id")
  content     String    @db.Text
  response    String?   @db.Text
  direction   String
  pushName    String?   @map("push_name")
  mediaUrl    String?   @map("media_url")
  mediaType   String?   @map("media_type") // 'image', 'video', 'audio', 'document'
  mediaData   Json?     @map("media_data") // JSON data for downloading media via Evolution API
  status      String    @default("pending") // 'pending' | 'processed' | 'failed'
  processedAt DateTime? @map("processed_at")
  companyId   String    @map("company_id")
  instanceId  String    @map("instance_id")
  createdAt   DateTime  @default(now()) @map("created_at")

  // Campos para suporte a grupos
  isGroup         Boolean @default(false) @map("is_group") // Se a mensagem é de um grupo
  participant     String? @map("participant") // JID do remetente dentro do grupo (ex: 5535999999999@s.whatsapp.net)
  participantName String? @map("participant_name") // Nome do remetente dentro do grupo

  // Relations
  quotedMessageId String?   @map("quoted_message_id")
  quotedMessage   Message?  @relation("MessageReplies", fields: [quotedMessageId], references: [id])
  replies         Message[] @relation("MessageReplies")

  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  instance Instance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([instanceId])
  @@index([remoteJid])
  @@index([quotedMessageId])
  @@map("messages")
}

model AISecretary {
  id                String    @id @default(cuid())
  companyId         String    @unique @map("company_id")
  enabled           Boolean   @default(false)
  mode              String    @default("passive") // 'passive' | 'active' | 'supervised'
  systemPrompt      String    @db.Text
  temperature       Float     @default(0.7)
  ownerPhone        String?   @map("owner_phone") // WhatsApp do dono para notificações
  ownerName         String?   @map("owner_name") // Nome do dono
  businessHours     String?   @map("business_hours") @db.Text // JSON com horários de funcionamento
  escalationWords   String?   @map("escalation_words") @db.Text // Palavras que sempre escalam para humano
  personality       String    @default("professional") // 'professional' | 'friendly' | 'casual'
  testMode          Boolean   @default(false) @map("test_mode") // Modo secretária pessoal
  ownerInstructions String?   @map("owner_instructions") @db.Text // Instruções temporárias do dono (ex: "diga que estou dormindo")
  instructionsUntil DateTime? @map("instructions_until") // Até quando as instruções são válidas
  transcribeAudio   Boolean   @default(true) @map("transcribe_audio") // Transcrever áudios automaticamente
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("ai_secretaries")
}

model Conversation {
  id              String    @id @default(cuid())
  remoteJid       String    @map("remote_jid")
  companyId       String    @map("company_id")
  instanceId      String    @map("instance_id")
  status          String    @default("active") // 'active' | 'waiting' | 'in_progress' | 'resolved' | 'archived'
  assignedTo      String?   @map("assigned_to") // 'ai' | userId
  assignedAgentId String?   @map("assigned_agent_id") // FK to User when assigned to human
  priority        String    @default("normal") // 'low' | 'normal' | 'high' | 'urgent'
  summary         String?   @db.Text
  aiEnabled       Boolean   @default(true) @map("ai_enabled") // IA habilitada nesta conversa
  lastMessageAt   DateTime  @map("last_message_at")
  assignedAt      DateTime? @map("assigned_at") // Quando foi atribuída
  resolvedAt      DateTime? @map("resolved_at") // Quando foi resolvida
  createdAt       DateTime  @default(now()) @map("created_at")

  company       Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  instance      Instance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  assignedAgent User?    @relation("AssignedAgent", fields: [assignedAgentId], references: [id])

  @@index([companyId, status])
  @@index([remoteJid, companyId])
  @@index([assignedAgentId])
  @@map("conversations")
}

model AIInteraction {
  id             String   @id @default(cuid())
  conversationId String   @map("conversation_id")
  messageId      String   @map("message_id")
  action         String // 'responded' | 'escalated' | 'summarized' | 'suggested'
  reasoning      String?  @db.Text
  confidence     Float?
  humanOverride  Boolean  @default(false) @map("human_override")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([conversationId])
  @@map("ai_interactions")
}

model Campaign {
  id          String    @id @default(cuid())
  name        String
  message     String    @db.Text
  mediaUrl    String?   @map("media_url")
  mediaType   String?   @map("media_type") // 'image' | 'video' | 'document'
  status      String    @default("draft") // 'draft' | 'scheduled' | 'running' | 'completed' | 'cancelled'
  scheduledAt DateTime? @map("scheduled_at")
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")

  // Segmentation filters
  targetAll          Boolean  @default(false) @map("target_all") // Send to all contacts
  targetTags         String[] @default([]) @map("target_tags")
  targetGenders      String[] @default([]) @map("target_genders")
  targetCities       String[] @default([]) @map("target_cities")
  targetStates       String[] @default([]) @map("target_states")
  targetUniversities String[] @default([]) @map("target_universities")
  targetCourses      String[] @default([]) @map("target_courses")
  targetMinAge       Int?     @map("target_min_age")
  targetMaxAge       Int?     @map("target_max_age")

  companyId  String   @map("company_id")
  instanceId String?  @map("instance_id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  company    Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  recipients CampaignRecipient[]

  @@map("campaigns")
}

model CampaignRecipient {
  id         String    @id @default(cuid())
  campaignId String    @map("campaign_id")
  remoteJid  String    @map("remote_jid")
  status     String    @default("pending") // 'pending' | 'sent' | 'failed'
  sentAt     DateTime? @map("sent_at")
  error      String?
  createdAt  DateTime  @default(now()) @map("created_at")

  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@map("campaign_recipients")
}

// Tarefas automatizadas da secretária
model SecretaryTask {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Metadata
  name        String // Nome curto da tarefa (ex: "Modo Dormir")
  description String @db.Text // Descrição detalhada

  // Condições (quando executar)
  // 'time_range' - Horário específico
  // 'keyword' - Palavra-chave na mensagem
  // 'first_message' - Primeira mensagem do contato
  // 'owner_inactive' - Dono inativo por X minutos  
  // 'always' - Sempre executa antes da resposta padrão
  triggerType   String @map("trigger_type")
  triggerConfig Json   @map("trigger_config") // Configuração específica do trigger

  // Ação (o que fazer)
  // 'send_message' - Enviar mensagem automática
  // 'add_to_response' - Adicionar texto à resposta da IA
  // 'forward_owner' - Notificar/encaminhar ao dono
  // 'set_tag' - Adicionar tag ao contato
  actionType   String @map("action_type")
  actionConfig Json   @map("action_config") // Configuração específica da ação

  // Controle
  isActive Boolean @default(true) @map("is_active")
  priority Int     @default(5) // 1-10, maior = mais prioritário

  // Audit
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by") // 'owner_chat', 'dashboard', etc

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, isActive])
  @@map("secretary_tasks")
}

// Estado do fluxo de despesas (para conversas multi-step)
model ExpenseFlowState {
  id        String @id @default(cuid())
  companyId String @map("company_id")
  remoteJid String @map("remote_jid")

  // Estado atual do fluxo
  step String @default("idle") // 'idle' | 'awaiting_wallet' | 'awaiting_wallet_type' | 'awaiting_items_confirmation' | 'awaiting_final_confirmation'

  // Dados temporários do fluxo (JSON)
  flowData Json @default("{}") @map("flow_data")

  // Metadados
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([companyId, remoteJid])
  @@index([expiresAt])
  @@map("expense_flow_states")
}

// Notificações em tempo real
model Notification {
  id        String  @id @default(cuid())
  companyId String  @map("company_id")
  userId    String? @map("user_id") // Null = todos os usuários da empresa

  // Tipo e categoria
  type     String // 'hot_lead' | 'escalation' | 'integration_error' | 'campaign_complete' | 'low_balance' | 'system' | 'task_reminder'
  category String @default("info") // 'info' | 'warning' | 'error' | 'success'

  // Conteúdo
  title    String
  message  String @db.Text
  metadata Json? // Dados extras (contactId, conversationId, etc)

  // Links para ação
  actionUrl   String? @map("action_url") // Ex: /chat/5535999999999
  actionLabel String? @map("action_label") // Ex: "Ver conversa"

  // Status
  read   Boolean   @default(false)
  readAt DateTime? @map("read_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([companyId, read])
  @@index([companyId, createdAt])
  @@index([userId])
  @@map("notifications")
}

// Integrações externas (Gastometria, etc)
model ExternalIntegration {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  provider String // 'gastometria', 'google_calendar', etc

  // Credenciais encriptadas (para re-autenticação)
  encryptedEmail    String? @map("encrypted_email") @db.Text
  encryptedPassword String? @map("encrypted_password") @db.Text

  // Tokens
  accessToken  String?   @map("access_token") @db.Text
  refreshToken String?   @map("refresh_token") @db.Text
  expiresAt    DateTime? @map("expires_at")

  // Dados extras (ex: walletId padrão do Gastometria)
  config Json @default("{}")

  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, provider])
  @@map("external_integrations")
}

// ================================
// AUTOMAÇÕES DE GRUPO
// ================================

// Regras de automação para grupos específicos
model GroupAutomation {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Identificação do grupo
  groupRemoteJid String? @map("group_remote_jid") // JID específico do grupo (opcional)
  groupNameMatch String? @map("group_name_match") // Padrão para match no nome do grupo (regex ou exato)

  // Configuração da regra
  name        String // Nome amigável da automação (ex: "Bolão Mega da Virada")
  description String? @db.Text // Descrição do que a automação faz
  isActive    Boolean @default(true) @map("is_active")

  // Padrão para capturar dados (regex)
  capturePattern String? @map("capture_pattern") @db.Text // Regex para capturar dados da mensagem

  // Tipo de ação
  actionType String @map("action_type") // 'collect_data' | 'auto_reply' | 'webhook' | 'aggregate' | 'ai_process'

  // Configuração da ação (JSON)
  actionConfig Json @default("{}") @map("action_config")
  // Para collect_data: { "dataType": "lottery_numbers", "fields": ["numbers", "participant"] }
  // Para auto_reply: { "replyTemplate": "Números registrados: {{numbers}}" }
  // Para webhook: { "url": "https://...", "method": "POST" }
  // Para aggregate: { "operation": "count" | "sum", "field": "value" }
  // Para ai_process: { "prompt": "Extrair números do bolão e confirmar" }

  // Validade temporal
  startsAt  DateTime? @map("starts_at")
  expiresAt DateTime? @map("expires_at")

  // Prioridade (maior = processado primeiro)
  priority Int @default(0)

  // Opções de resposta
  shouldReply   Boolean @default(true) @map("should_reply") // Se deve responder no grupo
  replyOnlyOnce Boolean @default(false) @map("reply_only_once") // Responder só 1x por participante
  skipAiAfter   Boolean @default(true) @map("skip_ai_after") // Pular processamento de IA após match

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company       Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  collectedData GroupAutomationData[]

  @@index([companyId, isActive])
  @@index([groupRemoteJid])
  @@map("group_automations")
}

// Dados coletados pelas automações
model GroupAutomationData {
  id           String @id @default(cuid())
  automationId String @map("automation_id")

  // Origem
  groupRemoteJid  String  @map("group_remote_jid")
  participantJid  String  @map("participant_jid") // Quem enviou
  participantName String? @map("participant_name")
  messageId       String? @map("message_id")

  // Dados coletados (JSON flexível)
  data Json // { "numbers": [1,2,3,4,5,6], "raw": "01 02 03 04 05 06" }

  // Metadados
  createdAt DateTime @default(now()) @map("created_at")

  automation GroupAutomation @relation(fields: [automationId], references: [id], onDelete: Cascade)

  @@index([automationId])
  @@index([groupRemoteJid, participantJid])
  @@map("group_automation_data")
}

// ================================
// AUTOMAÇÃO DE CONTATOS (Interação com Bots)
// ================================

// Perfil de automação para contatos específicos (ex: Copasa, Banco, etc)
model ContactAutomationProfile {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Identificação do contato
  remoteJid       String  @map("remote_jid") // JID do contato (ex: 5531800001@s.whatsapp.net)
  contactName     String  @map("contact_name") // Nome amigável (ex: "Copasa")
  contactNickname String? @map("contact_nickname") // Apelido alternativo para IA entender (ex: "empresa de água")
  profilePicUrl   String? @map("profile_pic_url")

  // Descrição do que este contato faz (para IA entender contexto)
  description String? @db.Text // "Empresa de água e esgoto de Minas Gerais"

  // Tipo de bot/atendimento
  botType String @default("menu") @map("bot_type") // 'menu' | 'free_text' | 'mixed'

  // Configurações de interação
  isActive       Boolean @default(true) @map("is_active")
  maxWaitSeconds Int     @default(120) @map("max_wait_seconds") // Timeout para respostas
  maxRetries     Int     @default(3) @map("max_retries") // Máximo de tentativas

  // Instruções específicas para IA navegar (opcional)
  navigationHints String? @map("navigation_hints") @db.Text // JSON com dicas de navegação

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  fields   ContactAutomationField[]
  sessions ContactAutomationSession[]

  @@unique([companyId, remoteJid])
  @@index([companyId, isActive])
  @@map("contact_automation_profiles")
}

// Campos personalizados para automação (ex: CPF, Identificador, Conta)
model ContactAutomationField {
  id        String @id @default(cuid())
  profileId String @map("profile_id")

  // Identificação do campo
  fieldName  String @map("field_name") // Nome técnico (ex: "cpf", "identificador")
  fieldLabel String @map("field_label") // Label amigável (ex: "CPF", "Número do Identificador")
  fieldValue String @map("field_value") @db.Text // Valor do campo

  // Como o bot pede este campo (para IA identificar)
  botPromptPatterns String[] @default([]) @map("bot_prompt_patterns") // ["digite seu cpf", "informe o cpf", "qual seu cpf"]

  // Tipo de dado para validação
  fieldType String @default("text") @map("field_type") // 'text' | 'number' | 'cpf' | 'phone' | 'date'

  // Ordem de prioridade (se bot pedir múltiplos dados)
  priority Int @default(0)

  // Se é obrigatório
  isRequired Boolean @default(true) @map("is_required")

  // Metadados
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  profile ContactAutomationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, fieldName])
  @@index([profileId])
  @@map("contact_automation_fields")
}

// Sessões de automação ativas (quando IA está interagindo com um bot)
model ContactAutomationSession {
  id        String @id @default(cuid())
  profileId String @map("profile_id")
  companyId String @map("company_id")

  // Quem solicitou a automação
  requestedBy   String @map("requested_by") // 'owner' | 'user_{userId}'
  requestedFrom String @map("requested_from") // remoteJid de onde veio a solicitação
  originalQuery String @map("original_query") @db.Text // "verificar com a copasa se estou sem água"

  // Status da sessão
  status String @default("pending") // 'pending' | 'navigating' | 'waiting_response' | 'completed' | 'failed' | 'timeout'

  // Objetivo da interação (extraído pela IA)
  objective     String  @map("objective") @db.Text // "Verificar falta de água na região"
  objectiveType String? @map("objective_type") // 'consulta' | 'reclamacao' | 'segunda_via' | 'informacao'

  // Histórico de navegação
  navigationLog Json @default("[]") @map("navigation_log") // Array de passos: [{step, botMessage, ourResponse, timestamp}]

  // Resultado final
  result        String? @db.Text // Resposta final do bot
  resultSummary String? @map("result_summary") @db.Text // Resumo da IA
  success       Boolean @default(false)

  // Controle de tempo
  startedAt   DateTime  @default(now()) @map("started_at")
  completedAt DateTime? @map("completed_at")
  expiresAt   DateTime  @map("expires_at") // Timeout automático

  // Última interação
  lastBotMessage  String?  @map("last_bot_message") @db.Text
  lastOurResponse String?  @map("last_our_response") @db.Text
  lastActivityAt  DateTime @default(now()) @map("last_activity_at")

  // Contagem
  messagesSent     Int @default(0) @map("messages_sent")
  messagesReceived Int @default(0) @map("messages_received")

  createdAt DateTime @default(now()) @map("created_at")

  profile ContactAutomationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([companyId, status])
  @@index([profileId])
  @@index([expiresAt])
  @@map("contact_automation_sessions")
}
