generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  picture   String?
  password  String?  @map("password")
  googleId  String?  @unique @map("google_id")
  companyId String   @map("company_id")
  role      String   @default("admin") // 'admin' | 'manager' | 'agent'
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company               Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  assignedConversations Conversation[] @relation("AssignedAgent")

  @@map("users")
}

model Company {
  id        String   @id @default(cuid())
  name      String
  balance   Decimal  @default(0) @db.Decimal(10, 2)
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Stripe Subscription fields
  stripeCustomerId        String?   @unique @map("stripe_customer_id")
  subscriptionId          String?   @unique @map("subscription_id")
  subscriptionStatus      String?   @map("subscription_status") // 'active' | 'past_due' | 'canceled' | 'trialing'
  planId                  String?   @map("plan_id") // 'starter' | 'professional' | 'business' | 'enterprise'
  billingPeriod           String?   @map("billing_period") // 'monthly' | 'yearly'
  subscriptionPeriodStart DateTime? @map("subscription_period_start")
  subscriptionPeriodEnd   DateTime? @map("subscription_period_end")
  cancelAtPeriodEnd       Boolean   @default(false) @map("cancel_at_period_end")

  // Usage limits based on plan
  maxInstances        Int  @default(1) @map("max_instances")
  maxMessagesPerMonth Int  @default(1000) @map("max_messages_per_month")
  maxContacts         Int  @default(500) @map("max_contacts")
  maxCampaigns        Int? @map("max_campaigns") // null = unlimited
  maxTeamMembers      Int  @default(1) @map("max_team_members")
  aiCreditsLimit      Int  @default(100) @map("ai_credits_limit")
  aiCreditsUsed       Int  @default(0) @map("ai_credits_used")

  users     User[]
  instances Instance[]

  messages         Message[]
  chatFlows        ChatFlow[]
  products         Product[]
  contacts         Contact[]
  aiSecretary      AISecretary?
  conversations    Conversation[]
  campaigns        Campaign[]
  secretaryTasks   SecretaryTask[]
  integrations     ExternalIntegration[]
  groupAutomations GroupAutomation[]

  @@map("companies")
}

model Contact {
  id            String   @id @default(cuid())
  remoteJid     String   @map("remote_jid")
  pushName      String?  @map("push_name")
  profilePicUrl String?  @map("profile_pic_url")
  notes         String?  @db.Text
  tags          String[] @default([])

  // Campos para identifica√ß√£o de grupos
  isGroup          Boolean @default(false) @map("is_group") // true se for um grupo
  groupName        String? @map("group_name") // Nome do grupo (subject)
  groupDescription String? @map("group_description") @db.Text // Descri√ß√£o do grupo

  // Campos demogr√°ficos para segmenta√ß√£o (apenas para contatos individuais)
  cep          String? // CEP para auto-preencher cidade/estado via ViaCEP
  birthDate    DateTime? @map("birth_date")
  gender       String? // 'male' | 'female' | 'other'
  city         String?
  state        String?
  neighborhood String? // Bairro (preenchido via ViaCEP)
  university   String?
  course       String?
  occupation   String?

  // Lead scoring e an√°lise de IA
  leadScore     Int?      @map("lead_score") // 0-100
  leadStatus    String?   @map("lead_status") // 'cold' | 'warm' | 'hot' | 'customer'
  aiAnalysis    String?   @map("ai_analysis") @db.Text // An√°lise detalhada da IA
  aiAnalyzedAt  DateTime? @map("ai_analyzed_at")
  totalMessages Int       @default(0) @map("total_messages")

  companyId  String   @map("company_id")
  instanceId String?  @map("instance_id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  company  Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  memories ContactMemory[]

  @@unique([remoteJid, companyId])
  @@map("contacts")
}

// Mem√≥ria estruturada por contato - evita reprocessar todo hist√≥rico
model ContactMemory {
  id        String @id @default(cuid())
  contactId String @map("contact_id")

  // Tipo de mem√≥ria
  type       String // 'fact' | 'preference' | 'need' | 'objection' | 'interest' | 'context'
  key        String // Ex: "nome_filho", "produto_interesse", "reclamacao"
  value      String  @db.Text // O valor da informa√ß√£o
  confidence Float   @default(1.0) // 0-1, confian√ßa na informa√ß√£o
  source     String? // messageId de onde veio a info

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([contactId, type, key])
  @@index([contactId])
  @@map("contact_memories")
}

// Base de conhecimento da empresa - treinamento espec√≠fico
model CompanyKnowledge {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  category String // 'product' | 'faq' | 'policy' | 'objection_handler' | 'script' | 'error_correction'
  title    String
  content  String   @db.Text
  keywords String[] @default([]) // Para busca r√°pida
  priority Int      @default(0) // Maior = mais importante
  isActive Boolean  @default(true) @map("is_active")

  // Para corre√ß√£o de erros
  wrongResponse   String? @map("wrong_response") @db.Text
  correctResponse String? @map("correct_response") @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([companyId, category])
  @@map("company_knowledge")
}

// ================================
// SISTEMA DE RAG - TREINAMENTO
// ================================

// Documento de treinamento (arquivos enviados pelo dono)
model TrainingDocument {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Metadados do documento
  name        String // Nome do arquivo/documento
  description String? @db.Text // Descri√ß√£o opcional
  sourceType  String  @map("source_type") // 'file' | 'text' | 'url' | 'whatsapp'
  mimeType    String? @map("mime_type") // 'application/pdf' | 'text/plain' | etc
  fileUrl     String? @map("file_url") @db.Text // URL do arquivo (se for upload)

  // Conte√∫do original (para refer√™ncia)
  originalContent String? @map("original_content") @db.Text

  // Status do processamento
  status       String  @default("pending") // 'pending' | 'processing' | 'completed' | 'failed'
  errorMessage String? @map("error_message") @db.Text

  // Estat√≠sticas
  chunkCount Int @default(0) @map("chunk_count") // Quantidade de chunks gerados
  tokenCount Int @default(0) @map("token_count") // Estimativa de tokens

  // Categoriza√ß√£o
  category String   @default("general") // 'product' | 'faq' | 'policy' | 'script' | 'general'
  tags     String[] @default([])

  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  chunks TrainingChunk[]

  @@index([companyId, status])
  @@index([companyId, category])
  @@map("training_documents")
}

// Chunks de documento com embeddings para RAG
model TrainingChunk {
  id         String @id @default(cuid())
  documentId String @map("document_id")
  companyId  String @map("company_id")

  // Conte√∫do do chunk
  content    String @db.Text
  chunkIndex Int    @map("chunk_index") // Ordem no documento original

  // Embedding para busca sem√¢ntica (armazenado como array de floats serializado)
  // Usamos JSON porque Postgres n√£o tem tipo nativo de vector sem extens√£o
  embedding String? @db.Text // JSON array de floats

  // Metadados para filtragem
  category String @default("general")
  metadata Json   @default("{}") // Metadados adicionais (p√°gina, se√ß√£o, etc)

  createdAt DateTime @default(now()) @map("created_at")

  document TrainingDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([companyId, category])
  @@index([documentId])
  @@map("training_chunks")
}

// Hist√≥rico de conversas para mem√≥ria de longo prazo
model ConversationSummary {
  id        String @id @default(cuid())
  companyId String @map("company_id")
  contactId String @map("contact_id")

  // Per√≠odo da conversa resumida
  startDate DateTime @map("start_date")
  endDate   DateTime @map("end_date")

  // Resumo gerado pela IA
  summary      String   @db.Text
  keyTopics    String[] @default([]) @map("key_topics") // T√≥picos principais
  keyFacts     String[] @default([]) @map("key_facts") // Fatos importantes mencionados
  decisions    String[] @default([]) // Decis√µes tomadas
  pendingItems String[] @default([]) @map("pending_items") // Itens pendentes

  // Sentimento geral e status
  overallSentiment String? @map("overall_sentiment") // 'positive' | 'neutral' | 'negative'

  // Embedding do resumo para busca sem√¢ntica
  embedding String? @db.Text

  messageCount Int      @default(0) @map("message_count")
  createdAt    DateTime @default(now()) @map("created_at")

  @@index([companyId, contactId])
  @@index([contactId, endDate])
  @@map("conversation_summaries")
}

model Product {
  id        String   @id @default(cuid())
  name      String
  variant   String?
  quantity  Int      @default(0)
  price     Decimal  @db.Decimal(10, 2)
  sku       String?
  imageUrl  String?  @map("image_url")
  isActive  Boolean  @default(true) @map("is_active")
  companyId String   @map("company_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("products")
}

model ChatFlow {
  id        String   @id @default(cuid())
  name      String
  keyword   String
  isActive  Boolean  @default(true) @map("is_active")
  companyId String   @map("company_id")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  nodes   ChatNode[]

  @@map("chat_flows")
}

model ChatNode {
  id        String  @id @default(cuid())
  flowId    String  @map("flow_id")
  content   String  @db.Text
  type      String  @default("text") // text, button, list
  stepIndex Int     @map("step_index")
  parentId  String? @map("parent_id")

  flow ChatFlow @relation(fields: [flowId], references: [id], onDelete: Cascade)

  @@map("chat_nodes")
}

model Instance {
  id          String    @id @default(cuid())
  name        String
  instanceKey String    @unique @map("instance_key")
  companyId   String    @map("company_id")
  status      String    @default("disconnected")
  errorReason String?   @map("error_reason") // Motivo do erro de conex√£o
  lastErrorAt DateTime? @map("last_error_at") // Quando ocorreu o √∫ltimo erro
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  company       Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  messages      Message[]
  conversations Conversation[]

  @@map("instances")
}

model Message {
  id          String    @id @default(cuid())
  remoteJid   String    @map("remote_jid")
  messageId   String    @unique @map("message_id")
  content     String    @db.Text
  response    String?   @db.Text
  direction   String
  pushName    String?   @map("push_name")
  mediaUrl    String?   @map("media_url")
  mediaType   String?   @map("media_type") // 'image', 'video', 'audio', 'document'
  mediaData   Json?     @map("media_data") // JSON data for downloading media via Evolution API
  status      String    @default("pending") // 'pending' | 'processed' | 'failed'
  processedAt DateTime? @map("processed_at")
  companyId   String    @map("company_id")
  instanceId  String    @map("instance_id")
  createdAt   DateTime  @default(now()) @map("created_at")

  // Campo para identificar origem da mensagem enviada
  senderType  String    @default("manual") @map("sender_type") // 'manual' | 'ai' | 'quick_reply' | 'campaign'

  // Campos para suporte a grupos
  isGroup         Boolean @default(false) @map("is_group") // Se a mensagem √© de um grupo
  participant     String? @map("participant") // JID do remetente dentro do grupo (ex: 5535999999999@s.whatsapp.net)
  participantName String? @map("participant_name") // Nome do remetente dentro do grupo

  // Relations
  quotedMessageId String?   @map("quoted_message_id")
  quotedMessage   Message?  @relation("MessageReplies", fields: [quotedMessageId], references: [id])
  replies         Message[] @relation("MessageReplies")

  company  Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  instance Instance @relation(fields: [instanceId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([instanceId])
  @@index([remoteJid])
  @@index([quotedMessageId])
  @@map("messages")
}

model AISecretary {
  id                String    @id @default(cuid())
  companyId         String    @unique @map("company_id")
  enabled           Boolean   @default(false)
  mode              String    @default("passive") // 'passive' | 'active' | 'supervised'
  systemPrompt      String    @db.Text
  temperature       Float     @default(0.7)
  ownerPhone        String?   @map("owner_phone") // WhatsApp do dono para notifica√ß√µes
  ownerName         String?   @map("owner_name") // Nome do dono
  businessHours     String?   @map("business_hours") @db.Text // JSON com hor√°rios de funcionamento
  escalationWords   String?   @map("escalation_words") @db.Text // Palavras que sempre escalam para humano
  personality       String    @default("professional") // 'professional' | 'friendly' | 'casual'
  testMode          Boolean   @default(false) @map("test_mode") // Modo secret√°ria pessoal
  ownerInstructions String?   @map("owner_instructions") @db.Text // Instru√ß√µes tempor√°rias do dono (ex: "diga que estou dormindo")
  instructionsUntil DateTime? @map("instructions_until") // At√© quando as instru√ß√µes s√£o v√°lidas
  transcribeAudio   Boolean   @default(true) @map("transcribe_audio") // Transcrever √°udios automaticamente
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("ai_secretaries")
}

model Conversation {
  id              String    @id @default(cuid())
  remoteJid       String    @map("remote_jid")
  companyId       String    @map("company_id")
  instanceId      String    @map("instance_id")
  status          String    @default("active") // 'active' | 'waiting' | 'in_progress' | 'resolved' | 'archived'
  assignedTo      String?   @map("assigned_to") // 'ai' | userId
  assignedAgentId String?   @map("assigned_agent_id") // FK to User when assigned to human
  priority        String    @default("normal") // 'low' | 'normal' | 'high' | 'urgent'
  summary         String?   @db.Text
  aiEnabled       Boolean   @default(true) @map("ai_enabled") // IA habilitada nesta conversa
  lastMessageAt   DateTime  @map("last_message_at")
  assignedAt      DateTime? @map("assigned_at") // Quando foi atribu√≠da
  resolvedAt      DateTime? @map("resolved_at") // Quando foi resolvida
  createdAt       DateTime  @default(now()) @map("created_at")

  company       Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  instance      Instance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  assignedAgent User?    @relation("AssignedAgent", fields: [assignedAgentId], references: [id])

  @@index([companyId, status])
  @@index([remoteJid, companyId])
  @@index([assignedAgentId])
  @@map("conversations")
}

model AIInteraction {
  id             String   @id @default(cuid())
  conversationId String   @map("conversation_id")
  messageId      String   @map("message_id")
  action         String // 'responded' | 'escalated' | 'summarized' | 'suggested'
  reasoning      String?  @db.Text
  confidence     Float?
  humanOverride  Boolean  @default(false) @map("human_override")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([conversationId])
  @@map("ai_interactions")
}

model Campaign {
  id          String    @id @default(cuid())
  name        String
  message     String    @db.Text
  mediaUrl    String?   @map("media_url")
  mediaType   String?   @map("media_type") // 'image' | 'video' | 'document'
  status      String    @default("draft") // 'draft' | 'scheduled' | 'running' | 'completed' | 'cancelled'
  scheduledAt DateTime? @map("scheduled_at")
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")

  // Segmentation filters
  targetAll          Boolean  @default(false) @map("target_all") // Send to all contacts
  targetTags         String[] @default([]) @map("target_tags")
  targetGenders      String[] @default([]) @map("target_genders")
  targetCities       String[] @default([]) @map("target_cities")
  targetStates       String[] @default([]) @map("target_states")
  targetUniversities String[] @default([]) @map("target_universities")
  targetCourses      String[] @default([]) @map("target_courses")
  targetMinAge       Int?     @map("target_min_age")
  targetMaxAge       Int?     @map("target_max_age")

  companyId  String   @map("company_id")
  instanceId String?  @map("instance_id")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  company    Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  recipients CampaignRecipient[]

  @@map("campaigns")
}

model CampaignRecipient {
  id         String    @id @default(cuid())
  campaignId String    @map("campaign_id")
  remoteJid  String    @map("remote_jid")
  status     String    @default("pending") // 'pending' | 'sent' | 'failed'
  sentAt     DateTime? @map("sent_at")
  error      String?
  createdAt  DateTime  @default(now()) @map("created_at")

  campaign Campaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  @@index([campaignId])
  @@map("campaign_recipients")
}

// Tarefas automatizadas da secret√°ria
model SecretaryTask {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Metadata
  name        String // Nome curto da tarefa (ex: "Modo Dormir")
  description String @db.Text // Descri√ß√£o detalhada

  // Condi√ß√µes (quando executar)
  // 'time_range' - Hor√°rio espec√≠fico
  // 'keyword' - Palavra-chave na mensagem
  // 'first_message' - Primeira mensagem do contato
  // 'owner_inactive' - Dono inativo por X minutos  
  // 'always' - Sempre executa antes da resposta padr√£o
  triggerType   String @map("trigger_type")
  triggerConfig Json   @map("trigger_config") // Configura√ß√£o espec√≠fica do trigger

  // A√ß√£o (o que fazer)
  // 'send_message' - Enviar mensagem autom√°tica
  // 'add_to_response' - Adicionar texto √† resposta da IA
  // 'forward_owner' - Notificar/encaminhar ao dono
  // 'set_tag' - Adicionar tag ao contato
  actionType   String @map("action_type")
  actionConfig Json   @map("action_config") // Configura√ß√£o espec√≠fica da a√ß√£o

  // Controle
  isActive Boolean @default(true) @map("is_active")
  priority Int     @default(5) // 1-10, maior = mais priorit√°rio

  // Audit
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  createdBy String?  @map("created_by") // 'owner_chat', 'dashboard', etc

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, isActive])
  @@map("secretary_tasks")
}

// Estado do fluxo de despesas (para conversas multi-step)
model ExpenseFlowState {
  id        String @id @default(cuid())
  companyId String @map("company_id")
  remoteJid String @map("remote_jid")

  // Estado atual do fluxo
  step String @default("idle") // 'idle' | 'awaiting_wallet' | 'awaiting_wallet_type' | 'awaiting_items_confirmation' | 'awaiting_final_confirmation'

  // Dados tempor√°rios do fluxo (JSON)
  flowData Json @default("{}") @map("flow_data")

  // Metadados
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([companyId, remoteJid])
  @@index([expiresAt])
  @@map("expense_flow_states")
}

// Notifica√ß√µes em tempo real
model Notification {
  id        String  @id @default(cuid())
  companyId String  @map("company_id")
  userId    String? @map("user_id") // Null = todos os usu√°rios da empresa

  // Tipo e categoria
  type     String // 'hot_lead' | 'escalation' | 'integration_error' | 'campaign_complete' | 'low_balance' | 'system' | 'task_reminder'
  category String @default("info") // 'info' | 'warning' | 'error' | 'success'

  // Conte√∫do
  title    String
  message  String @db.Text
  metadata Json? // Dados extras (contactId, conversationId, etc)

  // Links para a√ß√£o
  actionUrl   String? @map("action_url") // Ex: /chat/5535999999999
  actionLabel String? @map("action_label") // Ex: "Ver conversa"

  // Status
  read   Boolean   @default(false)
  readAt DateTime? @map("read_at")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([companyId, read])
  @@index([companyId, createdAt])
  @@index([userId])
  @@map("notifications")
}

// Integra√ß√µes externas (Gastometria, etc)
model ExternalIntegration {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  provider String // 'gastometria', 'google_calendar', etc

  // Credenciais encriptadas (para re-autentica√ß√£o)
  encryptedEmail    String? @map("encrypted_email") @db.Text
  encryptedPassword String? @map("encrypted_password") @db.Text

  // Tokens
  accessToken  String?   @map("access_token") @db.Text
  refreshToken String?   @map("refresh_token") @db.Text
  expiresAt    DateTime? @map("expires_at")

  // Dados extras (ex: walletId padr√£o do Gastometria)
  config Json @default("{}")

  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, provider])
  @@map("external_integrations")
}

// ================================
// AUTOMA√á√ïES DE GRUPO
// ================================

// Regras de automa√ß√£o para grupos espec√≠ficos
model GroupAutomation {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Identifica√ß√£o do grupo
  groupRemoteJid String? @map("group_remote_jid") // JID espec√≠fico do grupo (opcional)
  groupNameMatch String? @map("group_name_match") // Padr√£o para match no nome do grupo (regex ou exato)

  // Configura√ß√£o da regra
  name        String // Nome amig√°vel da automa√ß√£o (ex: "Bol√£o Mega da Virada")
  description String? @db.Text // Descri√ß√£o do que a automa√ß√£o faz
  isActive    Boolean @default(true) @map("is_active")

  // Padr√£o para capturar dados (regex)
  capturePattern String? @map("capture_pattern") @db.Text // Regex para capturar dados da mensagem

  // Tipo de a√ß√£o
  actionType String @map("action_type") // 'collect_data' | 'auto_reply' | 'webhook' | 'aggregate' | 'ai_process'

  // Configura√ß√£o da a√ß√£o (JSON)
  actionConfig Json @default("{}") @map("action_config")
  // Para collect_data: { "dataType": "lottery_numbers", "fields": ["numbers", "participant"] }
  // Para auto_reply: { "replyTemplate": "N√∫meros registrados: {{numbers}}" }
  // Para webhook: { "url": "https://...", "method": "POST" }
  // Para aggregate: { "operation": "count" | "sum", "field": "value" }
  // Para ai_process: { "prompt": "Extrair n√∫meros do bol√£o e confirmar" }

  // Validade temporal
  startsAt  DateTime? @map("starts_at")
  expiresAt DateTime? @map("expires_at")

  // Prioridade (maior = processado primeiro)
  priority Int @default(0)

  // Op√ß√µes de resposta
  shouldReply   Boolean @default(true) @map("should_reply") // Se deve responder no grupo
  replyOnlyOnce Boolean @default(false) @map("reply_only_once") // Responder s√≥ 1x por participante
  skipAiAfter   Boolean @default(true) @map("skip_ai_after") // Pular processamento de IA ap√≥s match

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  company       Company               @relation(fields: [companyId], references: [id], onDelete: Cascade)
  collectedData GroupAutomationData[]

  @@index([companyId, isActive])
  @@index([groupRemoteJid])
  @@map("group_automations")
}

// Dados coletados pelas automa√ß√µes
model GroupAutomationData {
  id           String @id @default(cuid())
  automationId String @map("automation_id")

  // Origem
  groupRemoteJid  String  @map("group_remote_jid")
  participantJid  String  @map("participant_jid") // Quem enviou
  participantName String? @map("participant_name")
  messageId       String? @map("message_id")

  // Dados coletados (JSON flex√≠vel)
  data Json // { "numbers": [1,2,3,4,5,6], "raw": "01 02 03 04 05 06" }

  // Metadados
  createdAt DateTime @default(now()) @map("created_at")

  automation GroupAutomation @relation(fields: [automationId], references: [id], onDelete: Cascade)

  @@index([automationId])
  @@index([groupRemoteJid, participantJid])
  @@map("group_automation_data")
}

// ================================
// AUTOMA√á√ÉO DE CONTATOS (Intera√ß√£o com Bots)
// ================================

// Perfil de automa√ß√£o para contatos espec√≠ficos (ex: Copasa, Banco, etc)
model ContactAutomationProfile {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  // Identifica√ß√£o do contato
  remoteJid       String  @map("remote_jid") // JID do contato (ex: 5531800001@s.whatsapp.net)
  contactName     String  @map("contact_name") // Nome amig√°vel (ex: "Copasa")
  contactNickname String? @map("contact_nickname") // Apelido alternativo para IA entender (ex: "empresa de √°gua")
  profilePicUrl   String? @map("profile_pic_url")

  // Descri√ß√£o do que este contato faz (para IA entender contexto)
  description String? @db.Text // "Empresa de √°gua e esgoto de Minas Gerais"

  // Tipo de bot/atendimento
  botType String @default("menu") @map("bot_type") // 'menu' | 'free_text' | 'mixed'

  // Configura√ß√µes de intera√ß√£o
  isActive       Boolean @default(true) @map("is_active")
  maxWaitSeconds Int     @default(120) @map("max_wait_seconds") // Timeout para respostas
  maxRetries     Int     @default(3) @map("max_retries") // M√°ximo de tentativas

  // Instru√ß√µes espec√≠ficas para IA navegar (opcional)
  navigationHints String? @map("navigation_hints") @db.Text // JSON com dicas de navega√ß√£o

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  fields      ContactAutomationField[]
  menuOptions ContactAutomationMenuOption[]
  sessions    ContactAutomationSession[]

  @@unique([companyId, remoteJid])
  @@index([companyId, isActive])
  @@map("contact_automation_profiles")
}

// Campos personalizados para automa√ß√£o (ex: CPF, Identificador, Conta)
model ContactAutomationField {
  id        String @id @default(cuid())
  profileId String @map("profile_id")

  // Identifica√ß√£o do campo
  fieldName  String @map("field_name") // Nome t√©cnico (ex: "cpf", "identificador")
  fieldLabel String @map("field_label") // Label amig√°vel (ex: "CPF", "N√∫mero do Identificador")
  fieldValue String @map("field_value") @db.Text // Valor do campo

  // Como o bot pede este campo (para IA identificar)
  botPromptPatterns String[] @default([]) @map("bot_prompt_patterns") // ["digite seu cpf", "informe o cpf", "qual seu cpf"]

  // Tipo de dado para valida√ß√£o
  fieldType String @default("text") @map("field_type") // 'text' | 'number' | 'cpf' | 'phone' | 'date'

  // Ordem de prioridade (se bot pedir m√∫ltiplos dados)
  priority Int @default(0)

  // Se √© obrigat√≥rio
  isRequired Boolean @default(true) @map("is_required")

  // Metadados
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  profile ContactAutomationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, fieldName])
  @@index([profileId])
  @@map("contact_automation_fields")
}

// Op√ß√µes de menu do bot (ex: 1 - Segunda via, 2 - Falta de √°gua)
model ContactAutomationMenuOption {
  id        String @id @default(cuid())
  profileId String @map("profile_id")

  // A op√ß√£o que deve ser enviada (ex: "1", "2", "sim", "nao")
  optionValue String @map("option_value")

  // O que esta op√ß√£o faz (para IA entender)
  optionLabel       String  @map("option_label") // "Segunda via de contas"
  optionDescription String? @map("option_description") @db.Text // Descri√ß√£o mais detalhada

  // Palavras-chave que indicam que esta op√ß√£o deve ser escolhida
  keywords String[] @default([]) // ["fatura", "segunda via", "conta", "boleto"]

  // Ordem de prioridade (se m√∫ltiplas op√ß√µes combinarem)
  priority Int @default(0)

  // Se esta √© uma op√ß√£o para sair/encerrar
  isExitOption Boolean @default(false) @map("is_exit_option")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  profile ContactAutomationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, optionValue])
  @@index([profileId])
  @@map("contact_automation_menu_options")
}

// Sess√µes de automa√ß√£o ativas (quando IA est√° interagindo com um bot)
model ContactAutomationSession {
  id        String @id @default(cuid())
  profileId String @map("profile_id")
  companyId String @map("company_id")

  // Quem solicitou a automa√ß√£o
  requestedBy   String @map("requested_by") // 'owner' | 'user_{userId}'
  requestedFrom String @map("requested_from") // remoteJid de onde veio a solicita√ß√£o
  originalQuery String @map("original_query") @db.Text // "verificar com a copasa se estou sem √°gua"

  // Status da sess√£o
  status String @default("pending") // 'pending' | 'navigating' | 'waiting_response' | 'completed' | 'failed' | 'timeout'

  // Objetivo da intera√ß√£o (extra√≠do pela IA)
  objective     String  @map("objective") @db.Text // "Verificar falta de √°gua na regi√£o"
  objectiveType String? @map("objective_type") // 'consulta' | 'reclamacao' | 'segunda_via' | 'informacao'

  // Hist√≥rico de navega√ß√£o
  navigationLog Json @default("[]") @map("navigation_log") // Array de passos: [{step, botMessage, ourResponse, timestamp}]

  // Resultado final
  result        String? @db.Text // Resposta final do bot
  resultSummary String? @map("result_summary") @db.Text // Resumo da IA
  success       Boolean @default(false)

  // Controle de tempo
  startedAt   DateTime  @default(now()) @map("started_at")
  completedAt DateTime? @map("completed_at")
  expiresAt   DateTime  @map("expires_at") // Timeout autom√°tico

  // √öltima intera√ß√£o
  lastBotMessage  String?  @map("last_bot_message") @db.Text
  lastOurResponse String?  @map("last_our_response") @db.Text
  lastActivityAt  DateTime @default(now()) @map("last_activity_at")

  // Contagem
  messagesSent     Int @default(0) @map("messages_sent")
  messagesReceived Int @default(0) @map("messages_received")

  createdAt DateTime @default(now()) @map("created_at")

  profile ContactAutomationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@index([companyId, status])
  @@index([profileId])
  @@index([expiresAt])
  @@map("contact_automation_sessions")
}

// ================================
// WEBHOOKS EXTERNOS (Coolify, GitHub, Jellyfin, etc)
// ================================

// Aplica√ß√£o de webhook (cada app externa tem sua pr√≥pria URL)
model WebhookApplication {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  name        String // "Coolify", "Jellyfin", "GitHub", etc.
  slug        String // usado na URL: /webhook/app/{slug}
  description String? @db.Text
  icon        String? // emoji ou URL do √≠cone
  color       String? // cor para identificar no UI

  isActive Boolean @default(true) @map("is_active")

  // Seguran√ßa - URLs permitidas (valida√ß√£o de origem)
  allowedOrigins String[] @default([]) @map("allowed_origins") // URLs que podem enviar webhooks
  secretToken    String?  @map("secret_token") // Token secreto para valida√ß√£o (header)

  // Configura√ß√µes gerais
  logEnabled Boolean @default(true) @map("log_enabled")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Rela√ß√µes
  events WebhookEvent[]
  logs   WebhookApplicationLog[]

  @@unique([companyId, slug])
  @@index([companyId, isActive])
  @@map("webhook_applications")
}

// Evento configur√°vel de webhook (ex: deployment_failed, backup_success)
model WebhookEvent {
  id            String @id @default(cuid())
  applicationId String @map("application_id")

  name        String // "Deploy Falhou", "Backup Conclu√≠do"
  description String? @db.Text

  // Identifica√ß√£o do evento no payload
  // Campo que identifica o evento (suporta nested: "data.type", "event", etc)
  eventField String @map("event_field") // ex: "event", "type", "action"
  eventValue String @map("event_value") // ex: "deployment_failed", "push"

  // Template da mensagem com placeholders {{campo}} ou {{campo.subcampo}}
  messageTemplate String @map("message_template") @db.Text

  // Contatos que recebem este evento espec√≠fico (IDs separados por v√≠rgula ou JSON)
  contactIds String[] @default([]) @map("contact_ids")

  isActive Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Rela√ß√£o
  application WebhookApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@index([applicationId, isActive])
  @@map("webhook_events")
}

// Log de webhooks recebidos por aplica√ß√£o
model WebhookApplicationLog {
  id            String @id @default(cuid())
  applicationId String @map("application_id")

  // Dados do webhook
  payload Json // Payload completo recebido
  headers Json? // Headers da requisi√ß√£o

  // Matching
  matchedEventId   String? @map("matched_event_id") // ID do evento que matchou
  matchedEventName String? @map("matched_event_name") // Nome do evento para refer√™ncia

  // Status do processamento
  status       String  @default("received") // 'received' | 'matched' | 'sent' | 'no_match' | 'failed'
  error        String? @db.Text
  messagesSent Int     @default(0) @map("messages_sent")

  createdAt DateTime @default(now()) @map("created_at")

  // Rela√ß√£o
  application WebhookApplication @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@index([applicationId, createdAt])
  @@index([applicationId, status])
  @@map("webhook_application_logs")
}

// Contatos globais para webhooks (pode ser vinculado a eventos espec√≠ficos)
model WebhookContact {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  name      String // Nome amig√°vel (ex: "Bruno - Admin")
  remoteJid String  @map("remote_jid") // WhatsApp JID
  isActive  Boolean @default(true) @map("is_active")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([companyId, remoteJid])
  @@index([companyId, isActive])
  @@map("webhook_contacts")
}

// Manter compatibilidade tempor√°ria - pode remover depois
model WebhookConfig {
  id        String @id @default(cuid())
  companyId String @unique @map("company_id")

  messageTemplate String  @default("üîî *Webhook Recebido*\n\n{{payload}}") @map("message_template") @db.Text
  logEnabled      Boolean @default(true) @map("log_enabled")
  secretToken     String? @map("secret_token")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("webhook_configs")
}

model WebhookLog {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  source       String?
  payload      Json
  headers      Json?
  status       String  @default("received")
  error        String? @db.Text
  messagesSent Int     @default(0) @map("messages_sent")

  createdAt DateTime @default(now()) @map("created_at")

  @@index([companyId, createdAt])
  @@map("webhook_logs")
}

model WebhookNotificationContact {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  name       String
  remoteJid  String   @map("remote_jid")
  isActive   Boolean  @default(true) @map("is_active")
  categories String[] @default([])

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([companyId, remoteJid])
  @@index([companyId, isActive])
  @@map("webhook_notification_contacts")
}

// Respostas r√°pidas pr√©-programadas para o chat ao vivo
model QuickReply {
  id        String @id @default(cuid())
  companyId String @map("company_id")

  title    String // Nome curto para identificar (ex: "Chave PIX", "Hor√°rio", "Endere√ßo")
  shortcut String? // Atalho de teclado (ex: "/pix", "/horario")
  content  String  @db.Text // Conte√∫do completo da mensagem
  category String  @default("geral") // 'geral' | 'vendas' | 'suporte' | 'pagamento' | 'informacoes'
  icon     String? // Emoji ou √≠cone para identificar visualmente
  order    Int     @default(0) // Ordem de exibi√ß√£o
  isActive Boolean @default(true) @map("is_active")
  usageCount Int   @default(0) @map("usage_count") // Contador de uso para ordenar por popularidade

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([companyId, isActive])
  @@index([companyId, shortcut])
  @@map("quick_replies")
}
